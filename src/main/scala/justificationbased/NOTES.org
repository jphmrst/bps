
* Manifest
** Scala files
*** Core
    - [[./COMPILE.lisp][COMPILE.lisp]] :: Compile directions.
    - [[./Datum.scala][Datum.scala]] ::
    - [[./DbClass.scala][DbClass.scala]] ::
    - [[./JTMS.scala][JTMS.scala]] ::
    - [[./JTRE.scala][JTRE.scala]] ::
    - [[./Just.scala][Just.scala]] ::
    - [[./Node.scala][Node.scala]] ::
    - [[./Rule.scala][Rule.scala]] ::
** Lisp files
*** Carnival example
    - [[./carnival.lisp][carnival.lisp]] ::
    - [[./carnival-ex.lisp][carnival-ex.lisp]] ::
    - [[./carnival-play.lisp][carnival-play.lisp]] ::
    - [[./carnival-load.lisp][carnival-load.lisp]] ::
*** Other
    - [[./jtest.lisp][jtest.lisp]] :: Simple shakedown procedure for JTRE
    - [[./jtms-ex.lisp][jtms-ex.lisp]] :: Examples for Justification-based TMS
**** Algebraic manipulation systems
     - [[./match.lisp][match.lisp]] :: Pattern matcher for algebraic manipulation systems
**** Dependency-directed search facility
     - [[./dds.lisp][dds.lisp]] ::
**** Pattern-matching, variables and unification
     - [[./unify.lisp][unify.lisp]] :: Variables and unification
     - [[./funify.lisp][funify.lisp]] :: Extra pattern-matching facilities for FTRE
     - [[./funify.rkt][funify.rkt]] ::
**** N-Queens example
     - [[./jqrule.lisp][jqrule.lisp]] ::
     - [[./jqueens.lisp][jqueens.lisp]] ::
     - [[./jqueens.rkt][jqueens.rkt]] ::
**** Slagel's SAINT program
     - [[./simplify.lisp][simplify.lisp]] :: Algebraic simplifier
     - [[./jsaint.lisp][jsaint.lisp]] :: Rational reconstruction of Slagel's SAINT program
     - [[./jsaint.rkt][jsaint.rkt]] ::
     - [[./jsaint-rules.rkt][jsaint-rules.rkt]] ::
     - [[./jsops.lisp][jsops.lisp]] :: Operators for JSAINT
     - [[./jsrules.lisp][jsrules.lisp]] :: Basic rules for JSAINT
     - [[./my.lisp][my.lisp]] :: Looks like a call to JSAINT
**** Sudoku example
     - [[./sudoku.lisp][sudoku.lisp]] ::
     - [[./sudoku-rule.lisp][sudoku-rule.lisp]] ::
** Racket files
*** Related to the core
    - [[./jtest.rkt][jtest.rkt]] ::
    - [[./jtms-ex.rkt][jtms-ex.rkt]] ::
    - [[./jtms.rkt][jtms.rkt]] ::
    - [[./jtre.rkt][jtre.rkt]] ::
    - [[./unify.rkt][unify.rkt]] ::
    - [[./utils.rkt][utils.rkt]] ::
*** Other
    - [[./bms-ex.rkt][bms-ex.rkt]] ::
    - [[./bms.rkt][bms.rkt]] ::
    - [[./jbms-ex.rkt][jbms-ex.rkt]] ::
    - [[./logic.rkt][logic.rkt]] ::
    - [[./match.rkt][match.rkt]] ::
    - [[./simplify.rkt][simplify.rkt]] ::
    - [[./tinytms-ex.rkt][tinytms-ex.rkt]] ::
    - [[./tinytms.rkt][tinytms.rkt]] ::

* Types to figure out
  :PROPERTIES:
  :VISIBILITY: all
  :END:
** Facts
   - Matchable?
   - Yes, for now at least
** Constructor argument types in Rule
   - Using intermediate type bound locally to rule
   - Should recheck arguments to =body=
     - Need both JTMS and JTRE?  Need something more?

* Add method stubs
  :PROPERTIES:
  :VISIBILITY: folded
  :END:
** WAIT DbClass
   - Two macro-related methods not completed
** WAIT Rule
   - Lots of macro stuff not completed
** DONE JTRE
** DONE Node
** DONE JTMS
** DONE Just
** DONE Datum

* Fill method stubs
  :PROPERTIES:
  :VISIBILITY: all
  :END:
** TODO [[./JTMS.scala][JTMS]] â€” current
** WAIT [[./JTRE.scala][JTRE]]
   - Come back to terms/unification.  Will need to change Fact from
     Matchable to a Term typeclass.
** WAIT [[./Rule.scala][Rule]]
   - Lots of macro stuff not completed
** WAIT DbClass
   - Two macro-related methods not completed
** DONE [[./Node.scala][Node]]
   - Interactive method left untranslated for now
** DONE Just
** DONE Datum
   - /Probably/ DONE

* Translate examples

* Document
** TODO JTMS
** TODO Just
** TODO Node
** TODO Rule
** TODO JTRE
** TODO Datum
** TODO DbClass
